#include "drawing-tool-select.h"
#include "drawingscene.h"
#include "drawingview.h"
#include "drawing-shape.h"
#include "transform-handle.h" // 使用正确的头文件
#include "transform-system.h" // 变换系统
#include <QMouseEvent>
#include <QPainter>
#include <QDebug>
#include <QTransform>
#include <QGraphicsScene>
#include <QGraphicsItem>
#include <QtMath>

AdvancedSelectTool::AdvancedSelectTool(QObject *parent)
    : ToolBase(parent), m_state(STATE_IDLE), m_activeHandle(0), m_transformStarted(false), m_handleManager(nullptr), m_transformManager(new TransformManager())
{
    // 确保初始化时没有选中对象
    m_selectedShapes.clear();
    m_initialTransforms.clear();
    m_initialPositions.clear();
    m_transformObjects.clear();
}

AdvancedSelectTool::~AdvancedSelectTool()
{
    // 清理资源
    m_selectedShapes.clear();
    m_initialTransforms.clear();
    m_initialPositions.clear();

    // 清理变换系统
    if (m_transformManager)
    {
        // 清理变换对象
        for (TransformObject *obj : m_transformObjects)
        {
            delete obj;
        }
        m_transformObjects.clear();

        delete m_transformManager;
        m_transformManager = nullptr;
    }

    // 清理手柄管理器
    if (m_handleManager)
    {
        delete m_handleManager;
        m_handleManager = nullptr;
    }
}

void AdvancedSelectTool::activate(DrawingScene *scene, DrawingView *view)
{
    ToolBase::activate(scene, view);
    if (view)
    {
        view->setDragMode(QGraphicsView::RubberBandDrag);
    }

    // 创建手柄管理器
    if (m_scene && !m_handleManager)
    {
        m_handleManager = new HandleManager(m_scene, this);
    }

    // 连接信号
    if (m_scene)
    {
        connect(m_scene, &DrawingScene::objectStateChanged, this, &AdvancedSelectTool::onObjectStateChanged, Qt::UniqueConnection);
        connect(m_scene, &DrawingScene::selectionChanged, this, &AdvancedSelectTool::onSelectionChanged, Qt::UniqueConnection);

        // 更新选择状态
        onSelectionChanged();
    }
}

void AdvancedSelectTool::deactivate()
{
    // 保存当前变换（如果有的话）
    if (m_state == STATE_TRANSFORMING)
    {
        endTransform();
    }

    if (m_view)
    {
        m_view->setDragMode(QGraphicsView::NoDrag);
    }

    // 断开信号连接
    if (m_scene)
    {
        disconnect(m_scene, &DrawingScene::objectStateChanged, this, &AdvancedSelectTool::onObjectStateChanged);
        disconnect(m_scene, &DrawingScene::selectionChanged, this, &AdvancedSelectTool::onSelectionChanged);
    }

    // 隐藏手柄
    if (m_handleManager)
    {
        m_handleManager->hideHandles();
    }

    // 清理选择
    m_selectedShapes.clear();
    m_initialTransforms.clear();
    m_initialPositions.clear();

    m_state = STATE_IDLE;
    m_activeHandle = 0;

    ToolBase::deactivate();
}

bool AdvancedSelectTool::mousePressEvent(QMouseEvent *event, const QPointF &scenePos)
{
    if (!m_scene)
        return false;

    // 检查是否点击了变换手柄
    if (m_handleManager)
    {
        TransformHandle::HandleType handleType = m_handleManager->getHandleAtPosition(scenePos);
        qDebug() << "Mouse at:" << scenePos << "Handle detected:" << handleType;
        if (handleType > 0)
        {
            // 开始变换操作
            m_state = STATE_TRANSFORMING;
            m_activeHandle = handleType;
            m_startPos = scenePos;
            m_lastPos = scenePos;
            m_transformStarted = false;
            qDebug() << "Starting transform with handle:" << handleType;

            // 设置活动手柄
            m_handleManager->setActiveHandle(handleType);

            // 使用统一的方法初始化变换状态
            startTransform(handleType, scenePos);

            return true; // 消费事件
        }
    }

    // 检查是否点击了已选中的对象
    QGraphicsItem *item = m_scene->itemAt(scenePos, QTransform());
    bool clickedOnSelected = false;
    
    if (item) {
        QList<QGraphicsItem *> selectedItems = m_scene->selectedItems();
        for (QGraphicsItem *selectedItem : selectedItems) {
            if (selectedItem == item) {
                clickedOnSelected = true;
                break;
            }
        }
    }

    if (clickedOnSelected)
    {
        // 点击了已选中的对象，开始移动
        m_state = STATE_MOVING;
        m_startPos = scenePos;
        m_lastPos = scenePos;
        return true; // 消费事件
    }
    
    // 如果点击了空白区域或未选中的对象
    if (item == nullptr)
    {
        // 点击了空白区域，清除选择
        m_scene->clearSelection();
    }
    
    // 不消费事件，让场景处理选择逻辑
    return false;
}

bool AdvancedSelectTool::mouseMoveEvent(QMouseEvent *event, const QPointF &scenePos)
{
    if (!m_scene)
        return false;

    switch (m_state)
    {
    case STATE_MOVING:
        // 移动选中的对象
        if (event->buttons() & Qt::LeftButton)
        {
            // 计算鼠标增量移动
            QPointF delta = scenePos - m_lastPos;
            
            // 使用增量移动的方法移动所有选中的对象
            for (int i = 0; i < m_selectedShapes.size(); ++i)
            {
                DrawingShape *shape = m_selectedShapes[i];
                if (!shape) continue;
                
                // 获取当前位置
                QPointF currentPos = shape->pos();
                
                // 应用增量移动
                QPointF newPos = currentPos + delta;
                
                // 设置新位置
                shape->setPos(newPos);
                
                // 更新初始位置记录，确保连续移动
                m_initialPositions[i] = newPos;
            }

            m_lastPos = scenePos;

            // 更新手柄位置
            updateTransformHandles();

            return true;
        }
        break;

    case STATE_TRANSFORMING:
        // 更新变换
        if (event->buttons() & Qt::LeftButton)
        {
            qDebug() << "Transforming - mouse moved to:" << scenePos << "lastPos:" << m_lastPos;
            updateTransform(scenePos);
            return true;
        }
        break;

    case STATE_IDLE:
    default:
        // 检查鼠标悬停在手柄上并改变光标
        if (m_handleManager && m_view)
        {
            TransformHandle::HandleType handleType = m_handleManager->getHandleAtPosition(scenePos);
            if (handleType > 0)
            {
                // 根据手柄类型设置光标
                switch (handleType)
                {
                case TransformHandle::TopLeft:
                case TransformHandle::BottomRight:
                    m_view->setCursor(Qt::SizeFDiagCursor);
                    break;
                case TransformHandle::TopRight:
                case TransformHandle::BottomLeft:
                    m_view->setCursor(Qt::SizeBDiagCursor);
                    break;
                case TransformHandle::Top:
                case TransformHandle::Bottom:
                    m_view->setCursor(Qt::SizeVerCursor);
                    break;
                case TransformHandle::Left:
                case TransformHandle::Right:
                    m_view->setCursor(Qt::SizeHorCursor);
                    break;
                case TransformHandle::Center:
                    m_view->setCursor(Qt::SizeAllCursor);
                    break;
                default:
                    m_view->setCursor(Qt::ArrowCursor);
                    break;
                }
                return false;
            }
            else
            {
                m_view->setCursor(Qt::ArrowCursor);
            }
        }
        break;
    }

    return false;
}

bool AdvancedSelectTool::mouseReleaseEvent(QMouseEvent *event, const QPointF &scenePos)
{
    Q_UNUSED(event)
    Q_UNUSED(scenePos)

    if (m_state == STATE_TRANSFORMING)
    {
        endTransform();
    }

    m_state = STATE_IDLE;
    m_activeHandle = 0;

    // 更新场景显示
    if (m_scene)
    {
        m_scene->update();
    }

    return true;
}

bool AdvancedSelectTool::mouseDoubleClickEvent(QMouseEvent *event, const QPointF &scenePos)
{
    Q_UNUSED(event)
    Q_UNUSED(scenePos)
    return false;
}

void AdvancedSelectTool::onObjectStateChanged(DrawingShape *shape)
{
    if (shape)
    {
        if (shape->isSelected())
        {
            updateTransformHandles();
        }
    }
}

void AdvancedSelectTool::onSelectionChanged()
{
    if (!m_scene)
        return;

    // 清空当前选择
    m_selectedShapes.clear();
    m_initialTransforms.clear();
    m_initialPositions.clear();

    // 清理旧的变换对象
    for (TransformObject *obj : m_transformObjects)
    {
        delete obj;
    }
    m_transformObjects.clear();
    m_transformManager->clearObjects();

    // 更新选中的对象
    QList<QGraphicsItem *> selectedItems = m_scene->selectedItems();
    for (QGraphicsItem *item : selectedItems)
    {
        DrawingShape *shape = qgraphicsitem_cast<DrawingShape *>(item);
        if (shape)
        {
            m_selectedShapes.append(shape);

            // 保存初始变换和位置
            m_initialTransforms.append(shape->transform().transform());
            m_initialPositions.append(shape->pos());

            // 创建变换对象 - 使用本地边界框作为初始边界
            QRectF localBounds = shape->boundingRect();
            TransformObject *transformObj = new TransformObject(localBounds);

            m_transformObjects.append(transformObj);
            m_transformManager->addObject(transformObj);
        }
    }

    // 重置状态 - 只有在没有选中对象时才重置
    if (m_selectedShapes.isEmpty()) {
        m_state = STATE_IDLE;
        m_activeHandle = 0;
        m_transformStarted = false;
    }

    // 更新手柄显示
    updateTransformHandles();
}

void AdvancedSelectTool::startTransform(int handleIndex, const QPointF &scenePos)
{
    m_activeHandle = handleIndex;
    m_startPos = scenePos;
    m_lastPos = scenePos;

    m_transformStarted = true;
    m_relativeTransform = QTransform(); // 重置相对变换

    // 保存初始状态，确保在整个变换过程中使用相同的状态
    m_initialBounds = calculateSelectionBounds();

    // 保存每个选中对象的初始变换矩阵和位置
    m_initialTransforms.clear();
    m_initialPositions.clear();
    for (DrawingShape *shape : m_selectedShapes)
    {
        if (shape)
        {
            m_initialTransforms.append(shape->transform().transform());
            m_initialPositions.append(shape->pos());
        }
    }

    // 使用变换系统保存状态
    m_transformManager->saveSelectionState();

    // 按照Inkscape SelTrans实现：计算变换中心(锚点)
    // 对于缩放操作，锚点是对角或对边
    // 对于旋转操作，锚点是几何中心
    switch (m_activeHandle)
    {
    case TransformHandle::TopLeft:
        // 左上角手柄，锚点是右下角
        m_anchorPoint = m_initialBounds.bottomRight();
        break;
    case TransformHandle::TopRight:
        // 右上角手柄，锚点是左下角
        m_anchorPoint = m_initialBounds.bottomLeft();
        break;
    case TransformHandle::BottomLeft:
        // 左下角手柄，锚点是右上角
        m_anchorPoint = m_initialBounds.topRight();
        break;
    case TransformHandle::BottomRight:
        // 右下角手柄，锚点是左上角
        m_anchorPoint = m_initialBounds.topLeft();
        break;
    case TransformHandle::Top:
        // 上边中点手柄，锚点是下边中点
        m_anchorPoint = QPointF(m_initialBounds.center().x(), m_initialBounds.bottom());
        break;
    case TransformHandle::Bottom:
        // 下边中点手柄，锚点是上边中点
        m_anchorPoint = QPointF(m_initialBounds.center().x(), m_initialBounds.top());
        break;
    case TransformHandle::Left:
        // 左边中点手柄，锚点是右边中点
        m_anchorPoint = QPointF(m_initialBounds.right(), m_initialBounds.center().y());
        break;
    case TransformHandle::Right:
        // 右边中点手柄，锚点是左边中点
        m_anchorPoint = QPointF(m_initialBounds.left(), m_initialBounds.center().y());
        break;
    case TransformHandle::Center:
        // 中心手柄，计算几何中心
        {
            QPointF geometricCenter(0, 0);
            for (DrawingShape *shape : m_selectedShapes) {
                if (shape) {
                    geometricCenter += shape->pos() + shape->boundingRect().center();
                }
            }
            if (!m_selectedShapes.isEmpty()) {
                geometricCenter /= m_selectedShapes.size();
            }
            m_anchorPoint = geometricCenter;
        }
        break;
    default:
        m_anchorPoint = m_initialBounds.center();
        break;
    }

    qDebug() << "Handle:" << m_activeHandle << "Anchor point:" << m_anchorPoint << "Initial bounds:" << m_initialBounds;
}

void AdvancedSelectTool::updateTransform(const QPointF &scenePos)
{
    if (m_initialBounds.isEmpty() || m_selectedShapes.isEmpty()) return;
    
    qDebug() << "Update transform: scenePos=" << scenePos << "anchor=" << m_anchorPoint << "handle=" << m_activeHandle;
    
    // 如果鼠标位置没有变化，不进行变换
    if (scenePos == m_lastPos) {
        return;
    }
    
    // 直接计算每个对象的新位置和变换
    for (int i = 0; i < m_selectedShapes.size(); ++i) {
        DrawingShape *shape = m_selectedShapes[i];
        if (!shape) continue;
        
        switch (m_activeHandle) {
            case TransformHandle::TopLeft:
            case TransformHandle::TopRight:
            case TransformHandle::BottomLeft:
            case TransformHandle::BottomRight:
                {
                    // 等比例缩放 - 使用增量缩放跟随鼠标
                    QPointF originalHandle;
                    switch (m_activeHandle) {
                        case TransformHandle::TopLeft:
                            originalHandle = m_initialBounds.topLeft();
                            break;
                        case TransformHandle::TopRight:
                            originalHandle = m_initialBounds.topRight();
                            break;
                        case TransformHandle::BottomLeft:
                            originalHandle = m_initialBounds.bottomLeft();
                            break;
                        case TransformHandle::BottomRight:
                            originalHandle = m_initialBounds.bottomRight();
                            break;
                    }
                    
                    qreal lastDistance = QLineF(m_anchorPoint, m_lastPos).length();
                    qreal currentDistance = QLineF(m_anchorPoint, scenePos).length();
                    
                    if (lastDistance > 0) {
                        qreal scaleRatio = currentDistance / lastDistance;
                        scaleRatio = qBound(0.9, scaleRatio, 1.1); // 限制增量缩放范围
                        
                        qDebug() << "Scale ratio:" << scaleRatio;
                        
                        // 获取当前位置和变换
                        QPointF currentPos = shape->pos();
                        QTransform currentTransform = shape->transform().transform();
                        
                        // 计算相对于锚点的缩放
                        QPointF relativePos = currentPos - m_anchorPoint;
                        QPointF newRelativePos = relativePos * scaleRatio;
                        QPointF newPos = m_anchorPoint + newRelativePos;
                        
                        shape->setPos(newPos);
                        
                        // 应用增量缩放变换
                        QTransform scaleTransform;
                        scaleTransform.scale(scaleRatio, scaleRatio);
                        QTransform newTransform = currentTransform * scaleTransform;
                        
                        DrawingTransform drawingTransform;
                        drawingTransform.setTransform(newTransform);
                        shape->setTransform(drawingTransform);
                    }
                }
                break;
                
            case TransformHandle::Top:
            case TransformHandle::Left:
            case TransformHandle::Right:
            case TransformHandle::Bottom:
                {
                    // 单轴拉伸 - 使用增量拉伸跟随鼠标
                    qreal scaleX = 1.0, scaleY = 1.0;
                    
                    if (m_activeHandle == TransformHandle::Top || m_activeHandle == TransformHandle::Bottom) {
                        // 垂直拉伸
                        qreal lastDistance = qAbs(m_lastPos.y() - m_anchorPoint.y());
                        qreal currentDistance = qAbs(scenePos.y() - m_anchorPoint.y());
                        
                        if (lastDistance > 0) {
                            scaleY = currentDistance / lastDistance;
                            scaleY = qBound(0.9, scaleY, 1.1); // 限制增量拉伸范围
                        }
                    } else {
                        // 水平拉伸
                        qreal lastDistance = qAbs(m_lastPos.x() - m_anchorPoint.x());
                        qreal currentDistance = qAbs(scenePos.x() - m_anchorPoint.x());
                        
                        if (lastDistance > 0) {
                            scaleX = currentDistance / lastDistance;
                            scaleX = qBound(0.9, scaleX, 1.1); // 限制增量拉伸范围
                        }
                    }
                    
                    qDebug() << "Stretch: scaleX=" << scaleX << "scaleY=" << scaleY;
                    
                    // 获取当前位置和变换
                    QPointF currentPos = shape->pos();
                    QTransform currentTransform = shape->transform().transform();
                    
                    // 计算相对于锚点的拉伸
                    QPointF relativePos = currentPos - m_anchorPoint;
                    QPointF newRelativePos = QPointF(relativePos.x() * scaleX, relativePos.y() * scaleY);
                    QPointF newPos = m_anchorPoint + newRelativePos;
                    
                    shape->setPos(newPos);
                    
                    // 应用增量拉伸变换
                    QTransform stretchTransform;
                    stretchTransform.scale(scaleX, scaleY);
                    QTransform newTransform = currentTransform * stretchTransform;
                    
                    DrawingTransform drawingTransform;
                    drawingTransform.setTransform(newTransform);
                    shape->setTransform(drawingTransform);
                }
                break;
                
            case TransformHandle::Center:
                {
                    // 旋转 - 使用累积旋转方式
                    QPointF startVector = m_startPos - m_anchorPoint;
                    QPointF currentVector = scenePos - m_anchorPoint;
                    
                    if (!qFuzzyIsNull(startVector.x()) || !qFuzzyIsNull(startVector.y())) {
                        qreal startAngle = qAtan2(startVector.y(), startVector.x());
                        qreal currentAngle = qAtan2(currentVector.y(), currentVector.x());
                        qreal totalAngle = currentAngle - startAngle;
                        
                        qDebug() << "Total rotation:" << totalAngle * 180.0 / M_PI << "degrees";
                        
                        // 计算相对于锚点的旋转
                        QPointF initialPos = m_initialPositions[i];
                        QPointF relativePos = initialPos - m_anchorPoint;
                        
                        // 应用累积旋转
                        qreal cos_a = qCos(totalAngle);
                        qreal sin_a = qSin(totalAngle);
                        QPointF newRelativePos(
                            relativePos.x() * cos_a - relativePos.y() * sin_a,
                            relativePos.x() * sin_a + relativePos.y() * cos_a
                        );
                        QPointF newPos = m_anchorPoint + newRelativePos;
                        
                        shape->setPos(newPos);
                        
                        // 应用旋转变换
                        QTransform rotateTransform;
                        rotateTransform.rotate(totalAngle * 180.0 / M_PI);
                        QTransform newTransform = m_initialTransforms[i] * rotateTransform;
                        
                        DrawingTransform drawingTransform;
                        drawingTransform.setTransform(newTransform);
                        shape->setTransform(drawingTransform);
                    }
                }
                break;
                
            default:
                break;
        }
    }
    
    // 更新最后鼠标位置
    m_lastPos = scenePos;
    
    // 重新计算选择边界框并更新手柄
    QRectF newBounds = calculateSelectionBounds();
    qDebug() << "New bounds after transform:" << newBounds;
    m_handleManager->updateHandles(newBounds);
    
    // 更新场景显示
    if (m_scene) {
        m_scene->update();
    }
}

void AdvancedSelectTool::endTransform()
{
    // 如果场景存在，设置为已修改
    if (m_scene)
    {
        m_scene->setModified(true);
    }

    // 重置活动手柄
    if (m_handleManager)
    {
        m_handleManager->setActiveHandle(static_cast<TransformHandle::HandleType>(0));
    }

    m_activeHandle = 0;
    m_transformStarted = false;
}

void AdvancedSelectTool::updateTransformHandles()
{
    if (!m_handleManager)
        return;

    // 计算当前选择边界框
    QRectF currentBounds = calculateSelectionBounds();
    
    // 只在选择变化时更新初始边界框，变换时保持不变
    if (m_state != STATE_TRANSFORMING)
    {
        m_initialBounds = currentBounds;
        qDebug() << "Updated initial bounds:" << m_initialBounds;
    }

    // 调试输出
    qDebug() << "Selection bounds:" << m_initialBounds << "Selected shapes count:" << m_selectedShapes.size();

    if (m_selectedShapes.isEmpty() || currentBounds.isEmpty())
    {
        // 没有选中对象或边界框为空，隐藏手柄
        m_handleManager->hideHandles();
    }
    else
    {
        // 有选中对象，更新并显示手柄
        // 始终使用当前边界框更新手柄位置
        m_handleManager->updateHandles(currentBounds);
        m_handleManager->showHandles();
    }
}

void AdvancedSelectTool::calculateScaleTransform(const QPointF &scenePos)
{
    Q_UNUSED(scenePos)
    // 实现缩放变换计算
    // 这里可以基于当前手柄和鼠标位置计算缩放因子
}

void AdvancedSelectTool::calculateRotateTransform(const QPointF &scenePos)
{
    Q_UNUSED(scenePos)
    // 实现旋转变换计算
    // 这里可以基于当前手柄和鼠标位置计算旋转角度
}

void AdvancedSelectTool::calculateSkewTransform(const QPointF &scenePos)
{
    Q_UNUSED(scenePos)
    // 实现倾斜变换计算
    // 这里可以基于当前手柄和鼠标位置计算倾斜参数
}

void AdvancedSelectTool::applyTransformToSelection()
{
    // 应用当前变换到选中的图形
    applyUniformTransform();
}

QRectF AdvancedSelectTool::calculateSelectionBounds() const
{
    if (m_selectedShapes.isEmpty())
        return QRectF();

    QRectF bounds;
    bool first = true;

    for (DrawingShape *shape : m_selectedShapes)
    {
        if (!shape)
            continue;

        // 直接获取场景边界框（已经包含变换）
        QRectF sceneBounds = shape->sceneBoundingRect();

        if (first)
        {
            bounds = sceneBounds;
            first = false;
        }
        else
        {
            bounds = bounds.united(sceneBounds);
        }
    }

    return bounds;
}

void AdvancedSelectTool::applyTransformSystemToShapes()
{
    if (m_selectedShapes.isEmpty() || m_transformObjects.isEmpty())
        return;

    // 关键：直接应用变换，但确保锚点正确
    // 对于每个图形，我们需要计算相对于锚点的变换

    for (int i = 0; i < m_selectedShapes.size() && i < m_transformObjects.size(); ++i)
    {
        DrawingShape *shape = m_selectedShapes[i];
        TransformObject *transformObj = m_transformObjects[i];

        if (!shape || !transformObj)
            continue;

        // 获取变换对象的组合变换矩阵
        QTransform transform = transformObj->combinedTransform();

        // 获取图形的初始位置
        QPointF initialPos = m_initialPositions[i];

        // 计算图形相对于锚点的位置
        QPointF relativePos = initialPos - m_anchorPoint;

        // 应用变换到相对位置
        QPointF transformedRelativePos = transform.map(relativePos);

        // 计算新的绝对位置
        QPointF newPos = m_anchorPoint + transformedRelativePos;

        // 设置图形位置
        shape->setPos(newPos);

        // 应用变换矩阵（但不包含平移部分）
        QTransform transformNoTranslate = transform;
        transformNoTranslate.setMatrix(transform.m11(), transform.m12(), transform.m13(),
                                       transform.m21(), transform.m22(), transform.m23(),
                                       0, 0, transform.m33());

        DrawingTransform drawingTransform;
        drawingTransform.setTransform(transformNoTranslate);
        shape->setTransform(drawingTransform);
    }

    // 更新场景显示
    if (m_scene)
    {
        m_scene->update();
    }
}

void AdvancedSelectTool::applyUniformTransform()
{
    // 保留此方法以备向后兼容，但实际使用applyTransformSystemToShapes
    applyTransformSystemToShapes();
}